package com.study_java8;

/**
 * Created by Doctor on 2016/9/21.
 */
public class Java_Basic_Class {
    //Java   业务成为了事实上的业务的开发后台
    //C++    称为了后台核心的编写
    //面向过程：指的是针对某一个问题单独提出解决方案以及代码开发
    //面向对象：以一种组件化的形式进行代码的设计，这样开发出来的代码最大的好处就是重用
    //封装型：保护内部的定义结构安全性
    //继承性：在已有的程序结构上继续扩充新的功能
    //多态性：指的是在某一个概念范围内的满足
    //OOA(面向对象的分析）->OOD（面向对象的分析)->OOP（面向对象的编程）
    //类似不能直接使用的,只有对象时能够直接使用的.对象时类产生了.能用的一定是对象/能用的一定是对象

    //声明对象：类名称 对象名称 = new 类名称();
    //分布式：类名称 对象名 = null;
    //        对象名称 = new 类名称();
    public static void main(String[] args){
        /*
         * 堆内存：保存每一个对象的属性内容，堆内存需要使用管机制new才可以开辟
         * 栈内存：保存的是一块堆内存的地址
         * 代码是由右边向左边执行
         * 代码是由右边向左边执行
         * 代码是由右边向左边执行
         * 引用类型的变量名存在于堆上：
         * 引用类型的变量名存在于堆上：
         */
        Book book = new Book();
        /*
         * ①类名称 ②对象名称 = ③new ④类名称();
         *  ①类名称：规定了对象的类型,即：对象可使用那些属性和方法；
         *  ②对象名称：如果要想使用对象,需要有一个名字,这个是一个唯一的标识；
         *  ③new：开辟新的堆内存空间,如果没有吃语句，对象无法实例化；
         *  ④类名称():调用了一个和类名称一样的方法,这就是构造函数
         */
        //分布定义
        Book book1 = null; //book1 没有指向对应的堆内存对象,它的内容就是null
        book1 = new Book(); //关键字new 就是开辟新的堆内存空间
        /*
         *构造方法是在实例化新对象（new)的时候调用一次
         * 在实际工作中,构造方法的核心作用:在类对象实例化的时候设置属性的初始化内容,构造方法是为属性初始化准备的
         * 如果一个类之中已经明确的定义了一个构造方法,那么不会再自动生成默认构造方法（所以自定义构造方法后,建议明确定义默认无参数构造方法）。
         * 在定义一个类的时候可以为属性直接设置默认值，但是这个默认值只有在构造执行完后才设置。但是构造方法属于整个构造过程的最后一步，既：是留给用户处理的步骤
         * 在对象实例化的过程中,一定会经历类的加载、内存的分配、默认值的设置、构造方法。
         * Eg: class Book{
         *                  private String title = "Java 开发“
         *                  //title现在的默认值与此构造方法没关系，再执行构造函数之前,title的默认值为：null
         *                  public Book(){
         *                      }
         *                }
         *只有在整个构造都完成之后,才会真正将“Java 开发”这个字符串的内容设置给title属性.之前（在没有构造之前）title都是其对应数据类型的默认值。
         */
        //一块堆内存可以同时被多个栈内存说指向，但是反过来，一块栈内存只能够保存一块堆空间的地址。
        //没有引用变量引用的堆内存对象为垃圾对象,要等到垃圾回收
        //在引用数据类型的关系里面：一块没有任何栈内存指向的堆内存空间就将称为垃圾,会不定期的被垃圾回收器GC回收
        //回收之后会释放掉其所占用的空间。虽然Java自带垃圾回收处理,但是在代码开发中应该尽量避免产生垃圾
        //直接使用未开辟堆内存空间的对象，会出现“NullPointerException"
        /*
         *book真正使用的的时候调用的肯定是堆内存空间，代表的是堆内存空间的地址
         * 如果没有栈内存指向的堆内存对象就成为密名对象，但是密码对象由于没有其他对象堆起进行引用。所以密名对象只能使用一次，就会成为垃圾，等待JVM回收
         * new Book().setTitle("测试密名对象");
         */
        book.setTitle("Java");
        book.price = 12.0;
        book.getInfo();
    }
}
class Book{
    public Book(){

    }
    private String title; //书的名字
    public void setTitle(String title){
        this.title = title;
    }
    public String getTitle(){
        return  this.toString();
    }
    double price; // 书的价格
    public void getInfo(){ //此方法将由对象调用
        System.out.println("图书名称：" + title +"，价格："+price);
    }
}